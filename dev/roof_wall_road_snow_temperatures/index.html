<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Roof, Wall, Road, Snow Temperatures · UrbanCanopy.jl</title><meta name="title" content="Roof, Wall, Road, Snow Temperatures · UrbanCanopy.jl"/><meta property="og:title" content="Roof, Wall, Road, Snow Temperatures · UrbanCanopy.jl"/><meta property="twitter:title" content="Roof, Wall, Road, Snow Temperatures · UrbanCanopy.jl"/><meta name="description" content="Documentation for UrbanCanopy.jl."/><meta property="og:description" content="Documentation for UrbanCanopy.jl."/><meta property="twitter:description" content="Documentation for UrbanCanopy.jl."/><meta property="og:url" content="https://urbancanopy.earthsci.dev/roof_wall_road_snow_temperatures/"/><meta property="twitter:url" content="https://urbancanopy.earthsci.dev/roof_wall_road_snow_temperatures/"/><link rel="canonical" href="https://urbancanopy.earthsci.dev/roof_wall_road_snow_temperatures/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">UrbanCanopy.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../clmu_introduction/">CLMU Introduction</a></li><li><a class="tocitem" href="../offline_mode/">Offline Mode</a></li><li><a class="tocitem" href="../albedos_radiative_fluxes/">Albedos and Radiative Fluxes</a></li><li><a class="tocitem" href="../heat_momentum_fluxes/">Heat and Momentum Fluxes</a></li><li class="is-active"><a class="tocitem" href>Roof, Wall, Road, Snow Temperatures</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Analysis"><span>Analysis</span></a></li></ul></li><li><a class="tocitem" href="../hydrology/">Hydrology</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Roof, Wall, Road, Snow Temperatures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Roof, Wall, Road, Snow Temperatures</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/main/docs/src/roof_wall_road_snow_temperatures.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Roof,-Wall,-Road,-Snow-Temperatures"><a class="docs-heading-anchor" href="#Roof,-Wall,-Road,-Snow-Temperatures">Roof, Wall, Road, Snow Temperatures</a><a id="Roof,-Wall,-Road,-Snow-Temperatures-1"></a><a class="docs-heading-anchor-permalink" href="#Roof,-Wall,-Road,-Snow-Temperatures" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Chapter 4 of the CLMU technical note describes the computation of temperatures for roof, sunlit wall, shaded wall, pervious road, and impervious road columns with optional snow overlays. Heat conduction through each surface column is governed by the 1D heat equation (Eq. 4.4):</p><p><span>$c \frac{\partial T}{\partial t} = \frac{\partial}{\partial z}\!\left[\lambda \frac{\partial T}{\partial z}\right]$</span></p><p>which is discretized automatically using <a href="https://github.com/SciML/MethodOfLines.jl">MethodOfLines.jl</a>.</p><p>The implementation provides modular components for:</p><ol><li><strong>PDE heat conduction</strong>: Automatic spatial discretization of the heat equation for roofs/walls (uniform grid, Eq. 4.5) and roads (exponential grid, Eq. 4.8) using MethodOfLines.jl</li><li><strong>Snow layer geometry</strong>: Node depths, thicknesses, and interfaces for up to 5 snow layers (Eqs. 4.9–4.10)</li><li><strong>Thermal properties</strong>: Soil conductivity via Farouki (1981) / Kersten number (Eqs. 4.77–4.82), snow conductivity via Jordan (1991) (Eq. 4.83), and volumetric heat capacities from de Vries (1963) (Eqs. 4.85–4.87)</li><li><strong>Interface conductivity</strong>: Harmonic mean across adjacent layers (Eq. 4.12)</li><li><strong>Heat flux</strong>: Fourier&#39;s law discretized across interfaces (Eq. 4.11)</li><li><strong>Surface energy flux</strong>: Net surface heat flux and its temperature derivative for the implicit scheme (Eqs. 4.26–4.29)</li><li><strong>Building temperature</strong>: Weighted wall/roof average for interior building temperature (Eqs. 4.37–4.38)</li><li><strong>Waste heat and air conditioning</strong>: HVAC waste heat distribution and air conditioning heat removal (Eqs. 4.55–4.56)</li><li><strong>Waste heat allocation</strong>: Distribution of waste heat and AC to pervious and impervious road surfaces (Eq. 4.27)</li><li><strong>Adjusted layer thickness</strong>: Road top layer thickness adjustment for  numerical accuracy (Eq. 4.30)</li><li><strong>Heating/cooling flux</strong>: HVAC heating and cooling fluxes based on building  temperature vs prescribed limits (Eqs. 4.51–4.54)</li><li><strong>Phase change energy</strong>: Energy excess/deficit for freezing/thawing assessment  (Eq. 4.59)</li><li><strong>Phase change adjustment</strong>: Ice/liquid mass adjustment and temperature  correction after phase change (Eqs. 4.60–4.65)</li><li><strong>Snow melt without layers</strong>: Snow melt when snow is present but has no  explicit layers (Eqs. 4.66–4.71)</li><li><strong>Grid discretization</strong>: Uniform grid for roofs/walls and exponential grid  for roads (Eqs. 4.5–4.8)</li><li><strong>Freezing point depression</strong>: Maximum liquid water content below freezing  via supercooled soil water (Eq. 4.58)</li><li><strong>Snow-soil blended heat capacity</strong>: Top layer heat capacity blending when  snow is present but has no explicit layers (Eq. 4.88)</li><li><strong>Phase change energy</strong>: Per-layer and total phase change energy for  freezing/thawing assessment (Eqs. 4.72–4.73)</li></ol><p><strong>Reference</strong>: Oleson, K.W., G.B. Bonan, J.J. Feddema, M. Vertenstein, and E. Kluzek, 2010: Technical Description of an Urban Parameterization for the Community Land Model (CLMU). NCAR Technical Note NCAR/TN-480+STR, National Center for Atmospheric Research, Boulder, CO, 168 pp. Chapter 4: Roof, Wall, Road, Snow Temperatures (pp. 91–109).</p><article><details class="docstring" open="true"><summary id="UrbanCanopy.SnowLayerGeometry"><a class="docstring-binding" href="#UrbanCanopy.SnowLayerGeometry"><code>UrbanCanopy.SnowLayerGeometry</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SnowLayerGeometry(; name=:SnowLayerGeometry)</code></pre><p>Computes the snow layer structure for a given snow depth, following Section 4.1 of Oleson et al. (2010). The snow pack has up to 5 layers, with thickness assignments depending on the total snow depth z_sno (pp. 92–93).</p><p>This component takes the total snow depth and number of snow layers as inputs and computes the layer thicknesses, node depths, and interface depths (Eqs. 4.9–4.10).</p><p>Note: The actual number of snow layers (snl) is determined by the snow depth according to the rules on pp. 92–93. This component computes geometry for a single snow layer (the simplest case), since multi-layer snow packing logic is procedural and typically handled outside the equation system.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.1, pp. 92–93.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L15-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.SoilThermalProperties"><a class="docstring-binding" href="#UrbanCanopy.SoilThermalProperties"><code>UrbanCanopy.SoilThermalProperties</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SoilThermalProperties(; name=:SoilThermalProperties)</code></pre><p>Computes the thermal conductivity and volumetric heat capacity for soil layers used in pervious road columns, following Section 4.3 of Oleson et al. (2010).</p><p>Thermal conductivity follows Farouki (1981) using the Kersten number method (Eqs. 4.77–4.82). Volumetric heat capacity follows de Vries (1963) (Eqs. 4.85–4.86).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.3, pp. 107–108.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L64-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.SnowThermalProperties"><a class="docstring-binding" href="#UrbanCanopy.SnowThermalProperties"><code>UrbanCanopy.SnowThermalProperties</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SnowThermalProperties(; name=:SnowThermalProperties)</code></pre><p>Computes the thermal conductivity and volumetric heat capacity for snow layers, following Section 4.3 of Oleson et al. (2010).</p><p>Thermal conductivity follows Jordan (1991) (Eq. 4.83). Volumetric heat capacity depends on the ice and liquid water content (Eq. 4.87).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.3, pp. 108–109.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L179-L189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.UrbanSurfaceThermalProperties"><a class="docstring-binding" href="#UrbanCanopy.UrbanSurfaceThermalProperties"><code>UrbanCanopy.UrbanSurfaceThermalProperties</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">UrbanSurfaceThermalProperties(; name=:UrbanSurfaceThermalProperties)</code></pre><p>Represents the prescribed thermal conductivity and heat capacity for roof, wall, and impervious road layers, following Section 4.3 of Oleson et al. (2010).</p><p>For roofs, walls, and impervious road layers (i = 1, ..., N_imprvrd), the thermal conductivity and heat capacity are specified by the surface dataset (Table 1.3). This component takes those prescribed values as parameters.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.3, pp. 106.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L233-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.InterfaceThermalConductivity"><a class="docstring-binding" href="#UrbanCanopy.InterfaceThermalConductivity"><code>UrbanCanopy.InterfaceThermalConductivity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">InterfaceThermalConductivity(; name=:InterfaceThermalConductivity)</code></pre><p>Computes the thermal conductivity at the interface between two adjacent layers using the harmonic mean formula (Eq. 4.12) from Section 4.1 of Oleson et al. (2010).</p><p>The interface conductivity is derived from continuity of heat flux at the interface (Eq. 4.13), resulting in a weighted harmonic mean of the two adjacent layer conductivities.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.1, Eq. 4.12, pp. 94.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L266-L277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.HeatFlux"><a class="docstring-binding" href="#UrbanCanopy.HeatFlux"><code>UrbanCanopy.HeatFlux</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">HeatFlux(; name=:HeatFlux)</code></pre><p>Computes the heat flux from layer i to layer i+1 using Fourier&#39;s law discretized across the interface (Eq. 4.11) from Section 4.1 of Oleson et al. (2010).</p><p>The flux is defined as positive upwards: F<em>i = -λ[z</em>{h,i}] * (T<em>i - T</em>{i+1}) / (z<em>{i+1} - z</em>i).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.1, Eq. 4.11, pp. 94.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L302-L311">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.SurfaceEnergyFlux"><a class="docstring-binding" href="#UrbanCanopy.SurfaceEnergyFlux"><code>UrbanCanopy.SurfaceEnergyFlux</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SurfaceEnergyFlux(; name=:SurfaceEnergyFlux)</code></pre><p>Computes the net heat flux into each urban surface and its derivative with respect to surface temperature, following Eqs. 4.26, 4.28, and 4.29 of Oleson et al. (2010).</p><p>The surface heat flux h is the sum of absorbed solar radiation, net longwave radiation, sensible and latent heat fluxes, and waste heat / air conditioning terms. The derivative ∂h/∂T is used in the linearized Crank-Nicholson scheme (Eq. 4.19).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.26–4.29, pp. 97–98.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L335-L346">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.BuildingTemperature"><a class="docstring-binding" href="#UrbanCanopy.BuildingTemperature"><code>UrbanCanopy.BuildingTemperature</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">BuildingTemperature(; name=:BuildingTemperature)</code></pre><p>Computes the internal building temperature from a weighted combination of inner layer wall and roof temperatures, following Eqs. 4.37–4.38 of Oleson et al. (2010).</p><p>The building temperature T<em>{iB} is constrained between prescribed minimum and maximum values (T</em>{iB,min} and T_{iB,max}).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.37–4.38, pp. 99.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L389-L400">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.WasteHeatAirConditioning"><a class="docstring-binding" href="#UrbanCanopy.WasteHeatAirConditioning"><code>UrbanCanopy.WasteHeatAirConditioning</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">WasteHeatAirConditioning(; name=:WasteHeatAirConditioning)</code></pre><p>Computes waste heat from space heating/air conditioning and heat removed by air conditioning, following Eqs. 4.55–4.56 of Oleson et al. (2010).</p><p>Waste heat is distributed to the pervious and impervious road surfaces. Air conditioning heat removal equals the cooling flux (Eq. 4.56).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.51–4.56, pp. 101–102.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L429-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.WasteHeatAllocation"><a class="docstring-binding" href="#UrbanCanopy.WasteHeatAllocation"><code>UrbanCanopy.WasteHeatAllocation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">WasteHeatAllocation(; name=:WasteHeatAllocation)</code></pre><p>Allocates total waste heat and air conditioning heat to individual urban surfaces, following Eq. 4.27 of Oleson et al. (2010).</p><p>Waste heat and air conditioning are applied ONLY to the pervious and impervious road surfaces (divided by <code>1 - W_roof</code>). Walls and roof receive zero waste heat and zero air conditioning.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eq. 4.27, pp. 97.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L549-L560">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.AdjustedLayerThickness"><a class="docstring-binding" href="#UrbanCanopy.AdjustedLayerThickness"><code>UrbanCanopy.AdjustedLayerThickness</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdjustedLayerThickness(; name=:AdjustedLayerThickness)</code></pre><p>Computes the adjusted top layer thickness for pervious and impervious road surfaces, following Eq. 4.30 of Oleson et al. (2010).</p><p>The adjustment uses a tunable parameter <code>c_a = 0.34</code> to compensate for the difference between layer-averaged and surface temperature in the numerical scheme.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eq. 4.30, pp. 98.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L590-L600">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.HeatingCoolingFlux"><a class="docstring-binding" href="#UrbanCanopy.HeatingCoolingFlux"><code>UrbanCanopy.HeatingCoolingFlux</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">HeatingCoolingFlux(; name=:HeatingCoolingFlux)</code></pre><p>Computes the heating and cooling fluxes applied to roofs, sunlit walls, and shaded walls, following Eqs. 4.51–4.54 of Oleson et al. (2010).</p><p>Heating is applied when the internal building temperature <code>T_iB</code> falls below the prescribed minimum <code>T_{iB,min}</code>. Cooling is applied when <code>T_iB</code> exceeds the prescribed maximum <code>T_{iB,max}</code>.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.51–4.54, pp. 101.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L626-L637">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.PhaseChangeEnergy"><a class="docstring-binding" href="#UrbanCanopy.PhaseChangeEnergy"><code>UrbanCanopy.PhaseChangeEnergy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PhaseChangeEnergy(; name=:PhaseChangeEnergy)</code></pre><p>Computes the energy excess or deficit for phase change assessment in a layer, following Eq. 4.59 of Oleson et al. (2010).</p><p>For the top layer (i = snl+1), the energy includes the surface heat flux and its derivative. For interior layers (i &gt; snl+1), only the heat fluxes and thermal storage are included.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.59–4.65, pp. 103–104.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L484-L495">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.PhaseChangeAdjustment"><a class="docstring-binding" href="#UrbanCanopy.PhaseChangeAdjustment"><code>UrbanCanopy.PhaseChangeAdjustment</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PhaseChangeAdjustment(; name=:PhaseChangeAdjustment)</code></pre><p>Performs the ice/liquid water mass adjustment and temperature correction after phase change, following Eqs. 4.60–4.65 of Oleson et al. (2010).</p><p>Given the excess/deficit energy <code>H_i</code> from Eq. 4.59, this component computes the melt/freeze amount <code>H_m</code>, adjusts ice mass, conserves liquid water, computes residual energy <code>H_{i*}</code>, and corrects the temperature.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.60–4.65, pp. 103–104.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L674-L685">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.SnowMeltNoLayers"><a class="docstring-binding" href="#UrbanCanopy.SnowMeltNoLayers"><code>UrbanCanopy.SnowMeltNoLayers</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SnowMeltNoLayers(; name=:SnowMeltNoLayers)</code></pre><p>Handles the special case of snow melt when snow is present (W_sno &gt; 0) but there are no explicit snow layers (snl = 0), following Eqs. 4.66–4.71 of Oleson et al. (2010).</p><p>When the snow mass is too small for explicit snow layers, snow melt is computed from the excess energy in the top soil layer. Snow mass and depth are reduced proportionally.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.66–4.71, pp. 105.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L761-L772">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.UniformGrid"><a class="docstring-binding" href="#UrbanCanopy.UniformGrid"><code>UrbanCanopy.UniformGrid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">UniformGrid(; name=:UniformGrid, N=15)</code></pre><p>Computes the uniform grid discretization for roofs and walls, following Eqs. 4.5–4.7 of Oleson et al. (2010). Roofs and walls are discretized into <code>N</code> layers of equal thickness, with node depths at layer midpoints and interface depths between layers.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.1, Eqs. 4.5–4.7, pp. 91.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L821-L829">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.ExponentialGrid"><a class="docstring-binding" href="#UrbanCanopy.ExponentialGrid"><code>UrbanCanopy.ExponentialGrid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ExponentialGrid(; name=:ExponentialGrid, N=15)</code></pre><p>Computes the exponential grid discretization for pervious and impervious road columns, following Eq. 4.8 and Eqs. 4.6–4.7 of Oleson et al. (2010). The scaling factor <code>f_s = 0.025</code> produces finer resolution near the surface, which is needed because roads overlie real soil.</p><p>Layer thicknesses and interface depths are computed from Eqs. 4.6 and 4.7.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.1, Eqs. 4.6–4.8, pp. 91–92.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L878-L889">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.FreezingPointDepression"><a class="docstring-binding" href="#UrbanCanopy.FreezingPointDepression"><code>UrbanCanopy.FreezingPointDepression</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FreezingPointDepression(; name=:FreezingPointDepression)</code></pre><p>Computes the maximum liquid water content in a soil layer when the temperature is below the freezing point, following Eq. 4.58 of Oleson et al. (2010).</p><p>The concept of supercooled soil water from Niu and Yang (2006) is used, where liquid water coexists with ice below freezing through a freezing point depression equation.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.2, Eq. 4.58, pp. 103.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L938-L948">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.SnowSoilBlendedHeatCapacity"><a class="docstring-binding" href="#UrbanCanopy.SnowSoilBlendedHeatCapacity"><code>UrbanCanopy.SnowSoilBlendedHeatCapacity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SnowSoilBlendedHeatCapacity(; name=:SnowSoilBlendedHeatCapacity)</code></pre><p>Computes the blended heat capacity of the top soil layer when snow is present but there are no explicit snow layers (snl = 0), following Eq. 4.88 of Oleson et al. (2010).</p><p>The heat capacity is the soil heat capacity (from Eq. 4.85) plus an additional term from the snow mass distributed over the top layer.</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Section 4.3, Eq. 4.88, pp. 109.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L992-L1002">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.LayerPhaseChangeEnergy"><a class="docstring-binding" href="#UrbanCanopy.LayerPhaseChangeEnergy"><code>UrbanCanopy.LayerPhaseChangeEnergy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">LayerPhaseChangeEnergy(; name=:LayerPhaseChangeEnergy)</code></pre><p>Computes the phase change energy for a single layer, following Eq. 4.73 of Oleson et al. (2010). This is used to sum contributions across all layers to obtain the total phase change energy (Eq. 4.72).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eq. 4.73, pp. 106.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L1028-L1036">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.TotalPhaseChangeEnergy"><a class="docstring-binding" href="#UrbanCanopy.TotalPhaseChangeEnergy"><code>UrbanCanopy.TotalPhaseChangeEnergy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">TotalPhaseChangeEnergy(; name=:TotalPhaseChangeEnergy)</code></pre><p>Computes the total phase change energy for the column, following Eq. 4.72 of Oleson et al. (2010). The total is the sum of the surface snow melt energy (Eq. 4.71) and the per-layer phase change energies (Eq. 4.73).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.72–4.73, pp. 105–106.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L1062-L1070">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.RoofWallHeatConduction"><a class="docstring-binding" href="#UrbanCanopy.RoofWallHeatConduction"><code>UrbanCanopy.RoofWallHeatConduction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">RoofWallHeatConduction(; name=:RoofWallHeatConduction)</code></pre><p>Implements the 1D heat conduction equation (Eq. 4.4) for roof and wall surfaces using MethodOfLines.jl for automatic spatial discretization.</p><p>The governing PDE is:     c ∂T/∂t = ∂/∂z [λ ∂T/∂z]</p><p>For roofs and walls, the domain is a uniform grid of total thickness Δz_total (Eq. 4.5). The boundary conditions are:</p><ul><li>Top (z=0): Neumann BC with surface heat flux h (Eq. 4.26)</li><li>Bottom (z=Δz<em>total): Dirichlet BC with building temperature T</em>iB (Eq. 4.37)</li></ul><p>The thermal conductivity λ and volumetric heat capacity c are prescribed parameters for each layer (from Table 1.3).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.1–4.4, pp. 90–91.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L1091-L1109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UrbanCanopy.RoadHeatConduction"><a class="docstring-binding" href="#UrbanCanopy.RoadHeatConduction"><code>UrbanCanopy.RoadHeatConduction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">RoadHeatConduction(; name=:RoadHeatConduction)</code></pre><p>Implements the 1D heat conduction equation (Eq. 4.4) for pervious and impervious road surfaces using MethodOfLines.jl for automatic spatial discretization.</p><p>For roads, the domain uses exponential spacing (Eq. 4.8) with the total depth determined by the scaling factor f_s = 0.025 m. The boundary conditions are:</p><ul><li>Top (z=0): Neumann BC with surface heat flux h (Eq. 4.26)</li><li>Bottom (z=z_max): Zero heat flux (Neumann BC, ∂T/∂z = 0)</li></ul><p>The thermal conductivity and heat capacity can vary with depth (e.g., impervious layers vs soil layers).</p><p><strong>Reference</strong>: Oleson et al. (2010), Chapter 4, Eqs. 4.1–4.4, 4.8, pp. 90–92.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthSciML/UrbanCanopy.jl/blob/48ed4055f0aad52eb855a387822aa74be1fa495f/src/roof_wall_road_snow_temperatures.jl#L1165-L1180">source</a></section></details></article><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><h3 id="Thermal-Properties-Components"><a class="docs-heading-anchor" href="#Thermal-Properties-Components">Thermal Properties Components</a><a id="Thermal-Properties-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Thermal-Properties-Components" title="Permalink"></a></h3><h4 id="Soil-Thermal-Properties"><a class="docs-heading-anchor" href="#Soil-Thermal-Properties">Soil Thermal Properties</a><a id="Soil-Thermal-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Soil-Thermal-Properties" title="Permalink"></a></h4><pre><code class="language-julia hljs">using DataFrames, ModelingToolkit, Symbolics, DynamicQuantities
using Statistics
using UrbanCanopy

sys_soil = SoilThermalProperties()

vars = unknowns(sys_soil)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>9×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">λ_s</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Thermal conductivity of soil solids (Eq. 4.79)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">λ_sat</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Saturated thermal conductivity (Eq. 4.78)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">ρ_d</td><td style = "text-align: left;">m⁻³ kg</td><td style = "text-align: left;">Bulk density of dry soil</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">λ_dry</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Dry thermal conductivity (Eq. 4.80)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">S_r</td><td style = "text-align: left;"></td><td style = "text-align: left;">Degree of saturation (Eq. 4.82) (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: left;">K_e</td><td style = "text-align: left;"></td><td style = "text-align: left;">Kersten number (Eq. 4.81) (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: left;">λ_soil</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Soil thermal conductivity (Eq. 4.77)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: left;">c_s</td><td style = "text-align: left;">m⁻¹ kg s⁻² K⁻¹</td><td style = "text-align: left;">Heat capacity of soil solids (Eq. 4.86)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: left;">c_soil</td><td style = "text-align: left;">m⁻¹ kg s⁻² K⁻¹</td><td style = "text-align: left;">Volumetric heat capacity of soil (Eq. 4.85)</td></tr></tbody></table></div><pre><code class="language-julia hljs">params = parameters(sys_soil)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(p, escape=false)) for p in params],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(p)) for p in params],
    :Description =&gt; [ModelingToolkit.getdescription(p) for p in params]
)</code></pre><div><div style = "float: left;"><span>26×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">λ_s_clay_coeff</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Empirical coefficient for clay in Eq. 4.79 (W m⁻¹ K⁻¹ per %)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">T_i</td><td style = "text-align: left;">K</td><td style = "text-align: left;">Temperature of layer</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">θ_liq</td><td style = "text-align: left;"></td><td style = "text-align: left;">Volumetric liquid water content (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">C_liq</td><td style = "text-align: left;">m² s⁻² K⁻¹</td><td style = "text-align: left;">Specific heat of liquid water (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">one_kgm⁻³</td><td style = "text-align: left;">m⁻³ kg</td><td style = "text-align: left;">Unit density for non-dimensionalization</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: left;">ρ_liq</td><td style = "text-align: left;">m⁻³ kg</td><td style = "text-align: left;">Density of liquid water (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: left;">w_ice</td><td style = "text-align: left;">m⁻² kg</td><td style = "text-align: left;">Ice mass in layer</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: left;">w_liq</td><td style = "text-align: left;">m⁻² kg</td><td style = "text-align: left;">Liquid water mass in layer</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: left;">λ_dry_denom_offset</td><td style = "text-align: left;"></td><td style = "text-align: left;">Empirical denominator offset in Eq. 4.80 (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: left;">ρ_ice</td><td style = "text-align: left;">m⁻³ kg</td><td style = "text-align: left;">Density of ice (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">11</td><td style = "text-align: left;">λ_liq_const</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Thermal conductivity of liquid water (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">12</td><td style = "text-align: left;">λ_dry_numerator_coeff</td><td style = "text-align: left;">m⁴ s⁻³ K⁻¹</td><td style = "text-align: left;">Empirical numerator coefficient in Eq. 4.80 (W m² kg⁻¹ K⁻¹)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">13</td><td style = "text-align: left;">T_f</td><td style = "text-align: left;">K</td><td style = "text-align: left;">Freezing temperature of water (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">14</td><td style = "text-align: left;">λ_dry_denom_coeff</td><td style = "text-align: left;"></td><td style = "text-align: left;">Empirical denominator coefficient in Eq. 4.80 (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">15</td><td style = "text-align: left;">θ_sat</td><td style = "text-align: left;"></td><td style = "text-align: left;">Porosity / volumetric water content at saturation (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">16</td><td style = "text-align: left;">ρ_mineral</td><td style = "text-align: left;">m⁻³ kg</td><td style = "text-align: left;">Mineral soil particle density</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">17</td><td style = "text-align: left;">c_s_sand_coeff</td><td style = "text-align: left;">m⁻¹ kg s⁻² K⁻¹</td><td style = "text-align: left;">Empirical coefficient for sand in Eq. 4.86 (J m⁻³ K⁻¹ per %)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">18</td><td style = "text-align: left;">λ_dry_numerator_offset</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Empirical numerator offset in Eq. 4.80</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">19</td><td style = "text-align: left;">one_Wm⁻¹K⁻¹</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Unit thermal conductivity for non-dimensionalization</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">20</td><td style = "text-align: left;">c_s_clay_coeff</td><td style = "text-align: left;">m⁻¹ kg s⁻² K⁻¹</td><td style = "text-align: left;">Empirical coefficient for clay in Eq. 4.86 (J m⁻³ K⁻¹ per %)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">21</td><td style = "text-align: left;">λ_ice_const</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Thermal conductivity of ice (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">22</td><td style = "text-align: left;">pct_clay</td><td style = "text-align: left;"></td><td style = "text-align: left;">Percent clay (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">23</td><td style = "text-align: left;">C_ice</td><td style = "text-align: left;">m² s⁻² K⁻¹</td><td style = "text-align: left;">Specific heat of ice (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">24</td><td style = "text-align: left;">Δz</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">25</td><td style = "text-align: left;">pct_sand</td><td style = "text-align: left;"></td><td style = "text-align: left;">Percent sand (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">26</td><td style = "text-align: left;">λ_s_sand_coeff</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Empirical coefficient for sand in Eq. 4.79 (W m⁻¹ K⁻¹ per %)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_soil)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{\lambda\_s}\left( t \right) &amp;= \frac{\mathtt{pct\_clay} \mathtt{\lambda\_s\_clay\_coeff} + \mathtt{pct\_sand} \mathtt{\lambda\_s\_sand\_coeff}}{\mathtt{pct\_clay} + \mathtt{pct\_sand}} \\
\mathtt{\lambda\_sat}\left( t \right) &amp;= ifelse\left( \mathtt{T\_i} \geq \mathtt{T\_f}, \left( \frac{\mathtt{\lambda\_s}\left( t \right)}{\mathtt{one\_Wm^-^{1}K^{- 1}}} \right)^{1 - \mathtt{\theta\_sat}} \left( \frac{\mathtt{\lambda\_liq\_const}}{\mathtt{one\_Wm^-^{1}K^{- 1}}} \right)^{\mathtt{\theta\_sat}} \mathtt{one\_Wm^-^{1}K^{- 1}}, \left( \frac{\mathtt{\lambda\_ice\_const}}{\mathtt{one\_Wm^-^{1}K^{- 1}}} \right)^{ - \mathtt{\theta\_liq} + \mathtt{\theta\_sat}} \left( \frac{\mathtt{\lambda\_s}\left( t \right)}{\mathtt{one\_Wm^-^{1}K^{- 1}}} \right)^{1 - \mathtt{\theta\_sat}} \left( \frac{\mathtt{\lambda\_liq\_const}}{\mathtt{one\_Wm^-^{1}K^{- 1}}} \right)^{\mathtt{\theta\_liq}} \mathtt{one\_Wm^-^{1}K^{- 1}} \right) \\
\mathtt{\rho\_d}\left( t \right) &amp;= \left( 1 - \mathtt{\theta\_sat} \right) \mathtt{\rho\_mineral} \\
\mathtt{\lambda\_dry}\left( t \right) &amp;= \frac{\mathtt{\lambda\_dry\_numerator\_offset} + \mathtt{\rho\_d}\left( t \right) \mathtt{\lambda\_dry\_numerator\_coeff}}{\frac{ - \mathtt{\rho\_d}\left( t \right) \mathtt{\lambda\_dry\_denom\_coeff}}{\mathtt{one\_kgm^{- 3}}} + \mathtt{\lambda\_dry\_denom\_offset}} \\
\mathtt{S\_r}\left( t \right) &amp;= \frac{\frac{\mathtt{w\_ice}}{\mathtt{{\Delta}z} \mathtt{\rho\_ice}} + \frac{\mathtt{w\_liq}}{\mathtt{{\Delta}z} \mathtt{\rho\_liq}}}{\mathtt{\theta\_sat}} \\
\mathtt{K\_e}\left( t \right) &amp;= ifelse\left( \mathtt{T\_i} \geq \mathtt{T\_f}, max\left( 1 + \log\left( max\left( \mathtt{S\_r}\left( t \right), 1 \cdot 10^{-10} \right) \right), 0 \right), \mathtt{S\_r}\left( t \right) \right) \\
\mathtt{\lambda\_soil}\left( t \right) &amp;= ifelse\left( \mathtt{S\_r}\left( t \right) &gt; 1 \cdot 10^{-7}, \mathtt{\lambda\_dry}\left( t \right) \left( 1 - \mathtt{K\_e}\left( t \right) \right) + \mathtt{K\_e}\left( t \right) \mathtt{\lambda\_sat}\left( t \right), \mathtt{\lambda\_dry}\left( t \right) \right) \\
\mathtt{c\_s}\left( t \right) &amp;= \frac{\mathtt{c\_s\_clay\_coeff} \mathtt{pct\_clay} + \mathtt{c\_s\_sand\_coeff} \mathtt{pct\_sand}}{\mathtt{pct\_clay} + \mathtt{pct\_sand}} \\
\mathtt{c\_soil}\left( t \right) &amp;= \frac{\mathtt{C\_ice} \mathtt{w\_ice}}{\mathtt{{\Delta}z}} + \frac{\mathtt{C\_liq} \mathtt{w\_liq}}{\mathtt{{\Delta}z}} + \mathtt{c\_s}\left( t \right) \left( 1 - \mathtt{\theta\_sat} \right)
\end{align}
 \]</p><h4 id="Snow-Thermal-Properties"><a class="docs-heading-anchor" href="#Snow-Thermal-Properties">Snow Thermal Properties</a><a id="Snow-Thermal-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Snow-Thermal-Properties" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_snow = SnowThermalProperties()

vars = unknowns(sys_snow)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>3×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">ρ_sno</td><td style = "text-align: left;">m⁻³ kg</td><td style = "text-align: left;">Snow bulk density (Eq. 4.84)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">λ_snow</td><td style = "text-align: left;">m kg s⁻³ K⁻¹</td><td style = "text-align: left;">Snow thermal conductivity (Eq. 4.83)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">c_snow</td><td style = "text-align: left;">m⁻¹ kg s⁻² K⁻¹</td><td style = "text-align: left;">Snow volumetric heat capacity (Eq. 4.87)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_snow)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{\rho\_sno}\left( t \right) &amp;= \frac{\mathtt{w\_ice} + \mathtt{w\_liq}}{\mathtt{{\Delta}z}} \\
\mathtt{\lambda\_snow}\left( t \right) &amp;= \mathtt{\lambda\_air} + \left( \mathtt{jordan\_linear\_coeff} \mathtt{\rho\_sno}\left( t \right) + \left( \mathtt{\rho\_sno}\left( t \right) \right)^{2} \mathtt{jordan\_quad\_coeff} \right) \left(  - \mathtt{\lambda\_air} + \mathtt{\lambda\_ice\_const} \right) \\
\mathtt{c\_snow}\left( t \right) &amp;= \frac{\mathtt{C\_ice} \mathtt{w\_ice}}{\mathtt{{\Delta}z}} + \frac{\mathtt{C\_liq} \mathtt{w\_liq}}{\mathtt{{\Delta}z}}
\end{align}
 \]</p><h4 id="Waste-Heat-Allocation"><a class="docs-heading-anchor" href="#Waste-Heat-Allocation">Waste Heat Allocation</a><a id="Waste-Heat-Allocation-1"></a><a class="docs-heading-anchor-permalink" href="#Waste-Heat-Allocation" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_wasteheat = WasteHeatAllocation()

vars = unknowns(sys_wasteheat)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>4×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">H_wasteheat_prvrd</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Waste heat to pervious road (Eq. 4.27)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">H_wasteheat_imprvrd</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Waste heat to impervious road (Eq. 4.27)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">H_aircond_prvrd</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Air conditioning heat to pervious road (Eq. 4.27)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">H_aircond_imprvrd</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Air conditioning heat to impervious road (Eq. 4.27)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_wasteheat)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{H\_wasteheat\_prvrd}\left( t \right) &amp;= \frac{\mathtt{H\_wasteheat}}{1 - \mathtt{W\_roof}} \\
\mathtt{H\_wasteheat\_imprvrd}\left( t \right) &amp;= \frac{\mathtt{H\_wasteheat}}{1 - \mathtt{W\_roof}} \\
\mathtt{H\_aircond\_prvrd}\left( t \right) &amp;= \frac{\mathtt{H\_aircond}}{1 - \mathtt{W\_roof}} \\
\mathtt{H\_aircond\_imprvrd}\left( t \right) &amp;= \frac{\mathtt{H\_aircond}}{1 - \mathtt{W\_roof}}
\end{align}
 \]</p><h4 id="Adjusted-Layer-Thickness"><a class="docs-heading-anchor" href="#Adjusted-Layer-Thickness">Adjusted Layer Thickness</a><a id="Adjusted-Layer-Thickness-1"></a><a class="docs-heading-anchor-permalink" href="#Adjusted-Layer-Thickness" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_alt = AdjustedLayerThickness()

vars = unknowns(sys_alt)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>1×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">Δz_star</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Adjusted top layer thickness (Eq. 4.30)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_alt)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{{\Delta}z\_star}\left( t \right) &amp;= 0.5 \left(  - \mathtt{z\_h\_im1} + \mathtt{z\_i} + \mathtt{c\_a} \left(  - \mathtt{z\_h\_im1} + \mathtt{z\_ip1} \right) \right)
\end{align}
 \]</p><h4 id="Heating/Cooling-Flux"><a class="docs-heading-anchor" href="#Heating/Cooling-Flux">Heating/Cooling Flux</a><a id="Heating/Cooling-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Heating/Cooling-Flux" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_hcf = HeatingCoolingFlux()

vars = unknowns(sys_hcf)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>3×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">F_combined</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Combined bottom flux (α*F^n + (1-α)*F^{n+1})</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">F_heat</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Heating flux (Eq. 4.51)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">F_cool</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Cooling flux (Eq. 4.52)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_hcf)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{F\_combined}\left( t \right) &amp;= \mathtt{F\_bottom\_n} \mathtt{\alpha\_CN} + \mathtt{F\_bottom\_np1} \left( 1 - \mathtt{\alpha\_CN} \right) \\
\mathtt{F\_heat}\left( t \right) &amp;= ifelse\left( \mathtt{T\_iB} &lt; \mathtt{T\_iB\_min}, \left|\mathtt{F\_combined}\left( t \right)\right|, \mathtt{zero\_flux} \right) \\
\mathtt{F\_cool}\left( t \right) &amp;= ifelse\left( \mathtt{T\_iB} &gt; \mathtt{T\_iB\_max}, \left|\mathtt{F\_combined}\left( t \right)\right|, \mathtt{zero\_flux} \right)
\end{align}
 \]</p><h4 id="Phase-Change-Adjustment"><a class="docs-heading-anchor" href="#Phase-Change-Adjustment">Phase Change Adjustment</a><a id="Phase-Change-Adjustment-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-Change-Adjustment" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_pca = PhaseChangeAdjustment(; layer_type=:interior)

vars = unknowns(sys_pca)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>5×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">H_m</td><td style = "text-align: left;">m⁻² kg</td><td style = "text-align: left;">Mass change potential H_i*Δt/L_f (Eq. 4.60)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">w_ice_np1</td><td style = "text-align: left;">m⁻² kg</td><td style = "text-align: left;">Ice mass at time n+1 (Eqs. 4.60-4.62)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">w_liq_np1</td><td style = "text-align: left;">m⁻² kg</td><td style = "text-align: left;">Liquid water mass at time n+1 (Eq. 4.63)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">H_residual</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Residual energy after phase change (Eq. 4.64)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">T_np1</td><td style = "text-align: left;">K</td><td style = "text-align: left;">Corrected temperature (Eq. 4.65)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_pca)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{H\_m}\left( t \right) &amp;= \frac{\mathtt{H\_i} \mathtt{{\Delta}t}}{\mathtt{L\_f}} \\
\mathtt{w\_ice\_np1}\left( t \right) &amp;= ifelse\left( \mathtt{H\_m}\left( t \right) &gt; \mathtt{zero\_kgm2}, max\left( \mathtt{w\_ice\_n} - \mathtt{H\_m}\left( t \right), \mathtt{zero\_kgm2} \right), min\left( \mathtt{w\_ice\_n} + \mathtt{w\_liq\_n}, \mathtt{w\_ice\_n} - \mathtt{H\_m}\left( t \right) \right) \right) \\
\mathtt{w\_liq\_np1}\left( t \right) &amp;= max\left( \mathtt{w\_ice\_n} + \mathtt{w\_liq\_n} - \mathtt{w\_ice\_np1}\left( t \right), \mathtt{zero\_kgm2} \right) \\
\mathtt{H\_residual}\left( t \right) &amp;= \mathtt{H\_i} + \frac{ - \mathtt{L\_f} \left( \mathtt{w\_ice\_n} - \mathtt{w\_ice\_np1}\left( t \right) \right)}{\mathtt{{\Delta}t}} \\
\mathtt{T\_np1}\left( t \right) &amp;= \mathtt{T\_f} + \frac{\mathtt{H\_residual}\left( t \right) \mathtt{{\Delta}t}}{\mathtt{c\_i} \mathtt{{\Delta}z\_i}}
\end{align}
 \]</p><h4 id="Snow-Melt-Without-Layers"><a class="docs-heading-anchor" href="#Snow-Melt-Without-Layers">Snow Melt Without Layers</a><a id="Snow-Melt-Without-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Snow-Melt-Without-Layers" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_sml = SnowMeltNoLayers()

vars = unknowns(sys_sml)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>5×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">W_sno_np1</td><td style = "text-align: left;">m⁻² kg</td><td style = "text-align: left;">Snow mass at time n+1 (Eq. 4.66)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">z_sno_np1</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Snow depth at time n+1 (Eq. 4.67)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">H_residual</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Residual energy after snow melt (Eq. 4.68)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">M_1S</td><td style = "text-align: left;">m⁻² kg s⁻¹</td><td style = "text-align: left;">Snow melt rate (Eq. 4.70)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">E_p1S</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Phase change energy (Eq. 4.71)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_sml)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{W\_sno\_np1}\left( t \right) &amp;= max\left( \mathtt{W\_sno\_n} + \frac{ - \mathtt{H\_1} \mathtt{{\Delta}t}}{\mathtt{L\_f}}, \mathtt{zero\_kgm2} \right) \\
\mathtt{z\_sno\_np1}\left( t \right) &amp;= ifelse\left( \mathtt{W\_sno\_n} &gt; \mathtt{zero\_kgm2}, \frac{\mathtt{z\_sno\_n} \mathtt{W\_sno\_np1}\left( t \right)}{\mathtt{W\_sno\_n}}, \mathtt{zero\_m} \right) \\
\mathtt{H\_residual}\left( t \right) &amp;= \mathtt{H\_1} + \frac{ - \mathtt{L\_f} \left( \mathtt{W\_sno\_n} - \mathtt{W\_sno\_np1}\left( t \right) \right)}{\mathtt{{\Delta}t}} \\
\mathtt{M\_1S}\left( t \right) &amp;= max\left( \frac{\mathtt{W\_sno\_n} - \mathtt{W\_sno\_np1}\left( t \right)}{\mathtt{{\Delta}t}}, \frac{\mathtt{zero\_kgm2}}{\mathtt{{\Delta}t}} \right) \\
\mathtt{E\_p1S}\left( t \right) &amp;= \mathtt{L\_f} \mathtt{M\_1S}\left( t \right)
\end{align}
 \]</p><h4 id="Grid-Discretization"><a class="docs-heading-anchor" href="#Grid-Discretization">Grid Discretization</a><a id="Grid-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Discretization" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_ug = UniformGrid(N=5)

vars = unknowns(sys_ug)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>16×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">z_node[1]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.5)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">z_node[2]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.5)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">z_node[3]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.5)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">z_node[4]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.5)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">z_node[5]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.5)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: left;">Δz_layer[1]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: left;">Δz_layer[2]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: left;">Δz_layer[3]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: left;">Δz_layer[4]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: left;">Δz_layer[5]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">11</td><td style = "text-align: left;">z_interface[1]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">12</td><td style = "text-align: left;">z_interface[2]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">13</td><td style = "text-align: left;">z_interface[3]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">14</td><td style = "text-align: left;">z_interface[4]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">15</td><td style = "text-align: left;">z_interface[5]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">16</td><td style = "text-align: left;">z_interface[6]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_ug)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{z\_node}\_{1}\left( t \right) &amp;= 0.1 \mathtt{{\Delta}z\_total} \\
\mathtt{z\_node}\_{2}\left( t \right) &amp;= 0.3 \mathtt{{\Delta}z\_total} \\
\mathtt{z\_node}\_{3}\left( t \right) &amp;= 0.5 \mathtt{{\Delta}z\_total} \\
\mathtt{z\_node}\_{4}\left( t \right) &amp;= 0.7 \mathtt{{\Delta}z\_total} \\
\mathtt{z\_node}\_{5}\left( t \right) &amp;= 0.9 \mathtt{{\Delta}z\_total} \\
\mathtt{{\Delta}z\_layer}\_{1}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{1}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{2}\left( t \right) &amp;= 0.5 \left(  - \mathtt{z\_node}\_{1}\left( t \right) + \mathtt{z\_node}\_{3}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{3}\left( t \right) &amp;= 0.5 \left(  - \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{4}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{4}\left( t \right) &amp;= 0.5 \left(  - \mathtt{z\_node}\_{3}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{5}\left( t \right) &amp;=  - \mathtt{z\_node}\_{4}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right) \\
\mathtt{z\_interface}\_{1}\left( t \right) &amp;= 0 \\
\mathtt{z\_interface}\_{2}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{1}\left( t \right) \right) \\
\mathtt{z\_interface}\_{3}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{3}\left( t \right) \right) \\
\mathtt{z\_interface}\_{4}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{3}\left( t \right) + \mathtt{z\_node}\_{4}\left( t \right) \right) \\
\mathtt{z\_interface}\_{5}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{4}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right) \right) \\
\mathtt{z\_interface}\_{6}\left( t \right) &amp;= 0.5 \mathtt{{\Delta}z\_layer}\_{5}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right)
\end{align}
 \]</p><pre><code class="language-julia hljs">sys_eg = ExponentialGrid(N=5)

vars = unknowns(sys_eg)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>16×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">z_node[1]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.8)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">z_node[2]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.8)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">z_node[3]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.8)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">z_node[4]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.8)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">z_node[5]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Node depth of layer i (Eq. 4.8)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: left;">Δz_layer[1]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: left;">Δz_layer[2]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: left;">Δz_layer[3]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: left;">Δz_layer[4]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: left;">Δz_layer[5]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness (Eq. 4.6)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">11</td><td style = "text-align: left;">z_interface[1]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">12</td><td style = "text-align: left;">z_interface[2]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">13</td><td style = "text-align: left;">z_interface[3]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">14</td><td style = "text-align: left;">z_interface[4]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">15</td><td style = "text-align: left;">z_interface[5]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">16</td><td style = "text-align: left;">z_interface[6]</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Interface depth (Eq. 4.7); index j maps to paper i=j-1</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_eg)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{z\_node}\_{1}\left( t \right) &amp;= 0.28403 \mathtt{f\_s} \\
\mathtt{z\_node}\_{2}\left( t \right) &amp;= 1.117 \mathtt{f\_s} \\
\mathtt{z\_node}\_{3}\left( t \right) &amp;= 2.4903 \mathtt{f\_s} \\
\mathtt{z\_node}\_{4}\left( t \right) &amp;= 4.7546 \mathtt{f\_s} \\
\mathtt{z\_node}\_{5}\left( t \right) &amp;= 8.4877 \mathtt{f\_s} \\
\mathtt{{\Delta}z\_layer}\_{1}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{1}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{2}\left( t \right) &amp;= 0.5 \left(  - \mathtt{z\_node}\_{1}\left( t \right) + \mathtt{z\_node}\_{3}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{3}\left( t \right) &amp;= 0.5 \left(  - \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{4}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{4}\left( t \right) &amp;= 0.5 \left(  - \mathtt{z\_node}\_{3}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right) \right) \\
\mathtt{{\Delta}z\_layer}\_{5}\left( t \right) &amp;=  - \mathtt{z\_node}\_{4}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right) \\
\mathtt{z\_interface}\_{1}\left( t \right) &amp;= 0 \\
\mathtt{z\_interface}\_{2}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{1}\left( t \right) \right) \\
\mathtt{z\_interface}\_{3}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{2}\left( t \right) + \mathtt{z\_node}\_{3}\left( t \right) \right) \\
\mathtt{z\_interface}\_{4}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{3}\left( t \right) + \mathtt{z\_node}\_{4}\left( t \right) \right) \\
\mathtt{z\_interface}\_{5}\left( t \right) &amp;= 0.5 \left( \mathtt{z\_node}\_{4}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right) \right) \\
\mathtt{z\_interface}\_{6}\left( t \right) &amp;= 0.5 \mathtt{{\Delta}z\_layer}\_{5}\left( t \right) + \mathtt{z\_node}\_{5}\left( t \right)
\end{align}
 \]</p><h4 id="Freezing-Point-Depression"><a class="docs-heading-anchor" href="#Freezing-Point-Depression">Freezing Point Depression</a><a id="Freezing-Point-Depression-1"></a><a class="docs-heading-anchor-permalink" href="#Freezing-Point-Depression" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_fpd = FreezingPointDepression()

vars = unknowns(sys_fpd)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>1×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">w_liq_max</td><td style = "text-align: left;">m⁻² kg</td><td style = "text-align: left;">Maximum liquid water when T &lt; T_f (Eq. 4.58)</td></tr></tbody></table></div><pre><code class="language-julia hljs">params = parameters(sys_fpd)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(p, escape=false)) for p in params],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(p)) for p in params],
    :Description =&gt; [ModelingToolkit.getdescription(p) for p in params]
)</code></pre><div><div style = "float: left;"><span>10×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">T_f</td><td style = "text-align: left;">K</td><td style = "text-align: left;">Freezing temperature of water (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">Δz</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Layer thickness</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">θ_sat</td><td style = "text-align: left;"></td><td style = "text-align: left;">Porosity (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">T_i</td><td style = "text-align: left;">K</td><td style = "text-align: left;">Layer temperature</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">one_ref</td><td style = "text-align: left;"></td><td style = "text-align: left;">Dimensionless reference for non-dimensionalization (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: left;">g</td><td style = "text-align: left;">m s⁻²</td><td style = "text-align: left;">Gravitational acceleration (Table 1.4)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: left;">ψ_sat</td><td style = "text-align: left;">m</td><td style = "text-align: left;">Saturated matric potential (converted to SI)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: left;">B_i</td><td style = "text-align: left;"></td><td style = "text-align: left;">Clapp and Hornberger exponent (dimensionless)</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: left;">ρ_liq</td><td style = "text-align: left;">m⁻³ kg</td><td style = "text-align: left;">Density of liquid water</td></tr><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: left;">L_f</td><td style = "text-align: left;">m² s⁻²</td><td style = "text-align: left;">Latent heat of fusion (Table 1.4)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_fpd)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{w\_liq\_max}\left( t \right) &amp;= ifelse\left( \mathtt{T\_i} &lt; \mathtt{T\_f}, \left( \frac{ - \mathtt{L\_f} \left( \mathtt{T\_f} - \mathtt{T\_i} \right) \mathtt{one\_ref}}{\mathtt{T\_i} g \mathtt{\psi\_sat}} \right)^{\frac{-1}{\mathtt{B\_i}}} \mathtt{{\Delta}z} \mathtt{\theta\_sat} \mathtt{\rho\_liq}, \mathtt{{\Delta}z} \mathtt{\theta\_sat} \mathtt{\rho\_liq} \right)
\end{align}
 \]</p><h4 id="Snow-Soil-Blended-Heat-Capacity"><a class="docs-heading-anchor" href="#Snow-Soil-Blended-Heat-Capacity">Snow-Soil Blended Heat Capacity</a><a id="Snow-Soil-Blended-Heat-Capacity-1"></a><a class="docs-heading-anchor-permalink" href="#Snow-Soil-Blended-Heat-Capacity" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_ssbhc = SnowSoilBlendedHeatCapacity()

vars = unknowns(sys_ssbhc)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>1×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">c_blended</td><td style = "text-align: left;">m⁻¹ kg s⁻² K⁻¹</td><td style = "text-align: left;">Blended heat capacity (Eq. 4.88)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_ssbhc)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{c\_blended}\left( t \right) &amp;= \mathtt{c\_soil} + \frac{\mathtt{C\_ice} \mathtt{W\_sno}}{\mathtt{{\Delta}z}}
\end{align}
 \]</p><h4 id="Phase-Change-Energy"><a class="docs-heading-anchor" href="#Phase-Change-Energy">Phase Change Energy</a><a id="Phase-Change-Energy-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-Change-Energy" title="Permalink"></a></h4><pre><code class="language-julia hljs">sys_lpe = LayerPhaseChangeEnergy()

vars = unknowns(sys_lpe)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>1×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">E_p</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Phase change energy for layer (Eq. 4.73)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_lpe)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{E\_p}\left( t \right) &amp;= \frac{\mathtt{L\_f} \left( \mathtt{w\_ice\_n} - \mathtt{w\_ice\_np1} \right)}{\mathtt{{\Delta}t}}
\end{align}
 \]</p><pre><code class="language-julia hljs">sys_tpce = TotalPhaseChangeEnergy()

vars = unknowns(sys_tpce)
DataFrame(
    :Name =&gt; [string(Symbolics.tosymbol(v, escape=false)) for v in vars],
    :Units =&gt; [dimension(ModelingToolkit.get_unit(v)) for v in vars],
    :Description =&gt; [ModelingToolkit.getdescription(v) for v in vars]
)</code></pre><div><div style = "float: left;"><span>1×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Name</th><th style = "text-align: left;">Units</th><th style = "text-align: left;">Description</th></tr><tr class = "columnLabelRow"><th class = "stubheadLabel" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}" style = "text-align: left;">Dimensio…</th><th title = "String" style = "text-align: left;">String</th></tr></thead><tbody><tr class = "dataRow"><td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">E_p_total</td><td style = "text-align: left;">kg s⁻³</td><td style = "text-align: left;">Total phase change energy (Eq. 4.72)</td></tr></tbody></table></div><pre><code class="language-julia hljs">eqs = equations(sys_tpce)</code></pre><p class="math-container">\[ \begin{align}
\mathtt{E\_p\_total}\left( t \right) &amp;= \mathtt{E\_p1S} + \mathtt{E\_p\_layers}
\end{align}
 \]</p><h2 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h2><h3 id="Soil-Thermal-Conductivity-vs-Saturation-(Eqs.-4.77–4.82)"><a class="docs-heading-anchor" href="#Soil-Thermal-Conductivity-vs-Saturation-(Eqs.-4.77–4.82)">Soil Thermal Conductivity vs Saturation (Eqs. 4.77–4.82)</a><a id="Soil-Thermal-Conductivity-vs-Saturation-(Eqs.-4.77–4.82)-1"></a><a class="docs-heading-anchor-permalink" href="#Soil-Thermal-Conductivity-vs-Saturation-(Eqs.-4.77–4.82)" title="Permalink"></a></h3><p>The Farouki (1981) thermal conductivity parameterization uses the Kersten number <span>$K_e$</span> to interpolate between dry (<span>$\lambda_{dry}$</span>) and saturated (<span>$\lambda_{sat}$</span>) conductivity. For unfrozen soil, <span>$K_e = \max(\log S_r + 1, 0)$</span> where <span>$S_r$</span> is the degree of saturation; for frozen soil, <span>$K_e = S_r$</span>.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqDefault

sys = SoilThermalProperties()
compiled = mtkcompile(sys)

function solve_soil(compiled, params)
    prob = ODEProblem(compiled, params, (0.0, 1.0))
    solve(prob)
end

function soil_params(compiled; pct_sand=60.0, pct_clay=20.0, θ_sat=0.4, θ_liq=0.0, T_i=293.15, w_liq=0.0, w_ice=0.0, Δz=0.5)
    Dict(
        compiled.pct_sand =&gt; pct_sand,
        compiled.pct_clay =&gt; pct_clay,
        compiled.θ_sat =&gt; θ_sat,
        compiled.θ_liq =&gt; θ_liq,
        compiled.T_i =&gt; T_i,
        compiled.w_ice =&gt; w_ice,
        compiled.w_liq =&gt; w_liq,
        compiled.Δz =&gt; Δz,
    )
end

# Sweep saturation for unfrozen and frozen conditions
S_r_range = 0.01:0.01:1.0
λ_unfrozen = Float64[]
λ_frozen = Float64[]
K_e_unfrozen = Float64[]
K_e_frozen = Float64[]

Δz = 0.5
θ_sat = 0.4
ρ_liq = 1000.0
ρ_ice = 917.0

for Sr in S_r_range
    # Unfrozen: w_liq = S_r * θ_sat * ρ_liq * Δz, θ_liq = S_r * θ_sat
    w_liq = Sr * θ_sat * ρ_liq * Δz
    p = soil_params(compiled; w_liq=w_liq, w_ice=0.0, θ_liq=Sr*θ_sat, T_i=293.15)
    sol = solve_soil(compiled, p)
    push!(λ_unfrozen, sol[compiled.λ_soil][end])
    push!(K_e_unfrozen, sol[compiled.K_e][end])

    # Frozen: w_ice = S_r * θ_sat * ρ_ice * Δz, θ_liq = 0 (all frozen)
    w_ice = Sr * θ_sat * ρ_ice * Δz
    p = soil_params(compiled; w_liq=0.0, w_ice=w_ice, θ_liq=0.0, T_i=263.15)
    sol = solve_soil(compiled, p)
    push!(λ_frozen, sol[compiled.λ_soil][end])
    push!(K_e_frozen, sol[compiled.K_e][end])
end

using Plots

p1 = plot(S_r_range, K_e_unfrozen, label=&quot;Unfrozen (log S_r + 1)&quot;, linewidth=2,
    xlabel=&quot;Degree of Saturation S_r&quot;, ylabel=&quot;Kersten Number K_e&quot;,
    title=&quot;Kersten Number (Eq. 4.81)&quot;, legend=:topleft)
plot!(p1, S_r_range, K_e_frozen, label=&quot;Frozen (K_e = S_r)&quot;, linewidth=2)

p2 = plot(S_r_range, λ_unfrozen, label=&quot;Unfrozen (T = 293 K)&quot;, linewidth=2,
    xlabel=&quot;Degree of Saturation S_r&quot;, ylabel=&quot;λ (W m⁻¹ K⁻¹)&quot;,
    title=&quot;Soil Thermal Conductivity (Eq. 4.77)&quot;, legend=:topleft)
plot!(p2, S_r_range, λ_frozen, label=&quot;Frozen (T = 263 K)&quot;, linewidth=2)

p = plot(p1, p2, layout=(2, 1), size=(700, 700))
p</code></pre><img src="b348aca9.svg" alt="Example block output"/><p>The unfrozen Kersten number shows a logarithmic dependence on saturation, reaching zero around <span>$S_r \approx 0.37$</span> (i.e., <span>$e^{-1}$</span>), below which the conductivity equals <span>$\lambda_{dry}$</span>. The frozen Kersten number is simply linear in saturation. At full saturation, the frozen conductivity exceeds the unfrozen value because ice has a higher thermal conductivity than liquid water.</p><h3 id="Soil-Thermal-Conductivity-by-Soil-Type"><a class="docs-heading-anchor" href="#Soil-Thermal-Conductivity-by-Soil-Type">Soil Thermal Conductivity by Soil Type</a><a id="Soil-Thermal-Conductivity-by-Soil-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Soil-Thermal-Conductivity-by-Soil-Type" title="Permalink"></a></h3><p>Different soil compositions (sand/clay fractions) yield different solid-phase conductivities <span>$\lambda_s$</span> (Eq. 4.79) and saturated conductivities <span>$\lambda_{sat}$</span> (Eq. 4.78). Sandy soils conduct heat more efficiently than clay soils.</p><pre><code class="language-julia hljs">soil_types = [
    (&quot;Sand (90/5)&quot;, 90.0, 5.0),
    (&quot;Sandy loam (60/15)&quot;, 60.0, 15.0),
    (&quot;Loam (40/25)&quot;, 40.0, 25.0),
    (&quot;Clay loam (30/35)&quot;, 30.0, 35.0),
    (&quot;Clay (10/50)&quot;, 10.0, 50.0),
]

S_r_range_soils = 0.01:0.02:1.0
p = plot(xlabel=&quot;Degree of Saturation S_r&quot;, ylabel=&quot;λ (W m⁻¹ K⁻¹)&quot;,
    title=&quot;Soil Conductivity by Type (Eqs. 4.77-4.80)&quot;, legend=:topleft)

for (name, sand, clay) in soil_types
    vals = Float64[]
    for Sr in S_r_range_soils
        w_liq = Sr * 0.4 * 1000.0 * 0.5
        pr = soil_params(compiled; pct_sand=sand, pct_clay=clay, w_liq=w_liq, θ_liq=Sr*0.4)
        sol = solve_soil(compiled, pr)
        push!(vals, sol[compiled.λ_soil][end])
    end
    plot!(p, S_r_range_soils, vals, label=name, linewidth=2)
end
p</code></pre><img src="58d25bce.svg" alt="Example block output"/><h3 id="Snow-Thermal-Conductivity-vs-Density-(Eq.-4.83)"><a class="docs-heading-anchor" href="#Snow-Thermal-Conductivity-vs-Density-(Eq.-4.83)">Snow Thermal Conductivity vs Density (Eq. 4.83)</a><a id="Snow-Thermal-Conductivity-vs-Density-(Eq.-4.83)-1"></a><a class="docs-heading-anchor-permalink" href="#Snow-Thermal-Conductivity-vs-Density-(Eq.-4.83)" title="Permalink"></a></h3><p>Snow thermal conductivity follows the Jordan (1991) parameterization, which is a quadratic function of snow bulk density <span>$\rho_{sno}$</span> (Eq. 4.83). As snow compacts, the increased contact area between ice grains raises the effective conductivity from near-air values (fresh snow) towards ice-like values (dense glacial ice).</p><pre><code class="language-julia hljs">sys_sn = SnowThermalProperties()
compiled_sn = mtkcompile(sys_sn)

ρ_range = 50.0:10.0:700.0
λ_vals = Float64[]
c_vals = Float64[]
Δz_sn = 0.2

for ρ in ρ_range
    w_ice = ρ * Δz_sn
    p = Dict(compiled_sn.w_ice =&gt; w_ice, compiled_sn.w_liq =&gt; 0.0, compiled_sn.Δz =&gt; Δz_sn)
    prob = ODEProblem(compiled_sn, p, (0.0, 1.0))
    sol = solve(prob)
    push!(λ_vals, sol[compiled_sn.λ_snow][end])
    push!(c_vals, sol[compiled_sn.c_snow][end])
end

p1 = plot(ρ_range, λ_vals, linewidth=2, label=&quot;λ_snow (Jordan 1991)&quot;,
    xlabel=&quot;Snow Density (kg m⁻³)&quot;, ylabel=&quot;λ (W m⁻¹ K⁻¹)&quot;,
    title=&quot;Snow Thermal Conductivity (Eq. 4.83)&quot;, legend=:topleft)
hline!(p1, [0.023], label=&quot;λ_air&quot;, linestyle=:dash, color=:gray)
hline!(p1, [2.29], label=&quot;λ_ice&quot;, linestyle=:dash, color=:blue)

p2 = plot(ρ_range, c_vals ./ 1e6, linewidth=2, label=&quot;c_snow&quot;,
    xlabel=&quot;Snow Density (kg m⁻³)&quot;, ylabel=&quot;c (MJ m⁻³ K⁻¹)&quot;,
    title=&quot;Snow Heat Capacity (Eq. 4.87)&quot;, legend=:topleft, color=:red)

p = plot(p1, p2, layout=(2, 1), size=(700, 700))
p</code></pre><img src="25cb7a49.svg" alt="Example block output"/><p>Fresh snow (<span>$\rho \approx 50$</span> kg m⁻³) has a conductivity only slightly above air, making it an effective insulator. As snow compacts beyond 400 kg m⁻³, the quadratic term dominates and conductivity increases rapidly. The heat capacity scales linearly with density since it depends on the mass of ice per unit volume.</p><h3 id="Interface-Thermal-Conductivity-(Eq.-4.12)"><a class="docs-heading-anchor" href="#Interface-Thermal-Conductivity-(Eq.-4.12)">Interface Thermal Conductivity (Eq. 4.12)</a><a id="Interface-Thermal-Conductivity-(Eq.-4.12)-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-Thermal-Conductivity-(Eq.-4.12)" title="Permalink"></a></h3><p>The interface thermal conductivity is a harmonic mean weighted by the distances from each node to the interface. When the interface is at the midpoint, this reduces to the standard harmonic mean of the two layer conductivities.</p><pre><code class="language-julia hljs">sys_itc = InterfaceThermalConductivity()
compiled_itc = mtkcompile(sys_itc)

λ_2_range = 0.1:0.1:10.0
λ_int_midpoint = Float64[]
λ_int_offset = Float64[]

for λ2 in λ_2_range
    # Midpoint interface
    p = Dict(compiled_itc.λ_i =&gt; 1.0, compiled_itc.λ_ip1 =&gt; λ2,
        compiled_itc.z_i =&gt; 0.0, compiled_itc.z_ip1 =&gt; 1.0, compiled_itc.z_h =&gt; 0.5)
    prob = ODEProblem(compiled_itc, p, (0.0, 1.0))
    sol = solve(prob)
    push!(λ_int_midpoint, sol[compiled_itc.λ_interface][end])

    # Interface at 1/4 point
    p2 = Dict(compiled_itc.λ_i =&gt; 1.0, compiled_itc.λ_ip1 =&gt; λ2,
        compiled_itc.z_i =&gt; 0.0, compiled_itc.z_ip1 =&gt; 1.0, compiled_itc.z_h =&gt; 0.25)
    prob2 = ODEProblem(compiled_itc, p2, (0.0, 1.0))
    sol2 = solve(prob2)
    push!(λ_int_offset, sol2[compiled_itc.λ_interface][end])
end

p = plot(λ_2_range, λ_int_midpoint, label=&quot;Midpoint (z_h = 0.5)&quot;, linewidth=2,
    xlabel=&quot;λ₂ (W m⁻¹ K⁻¹)&quot;, ylabel=&quot;λ_interface (W m⁻¹ K⁻¹)&quot;,
    title=&quot;Interface Conductivity (Eq. 4.12), λ₁ = 1&quot;, legend=:topleft)
plot!(p, λ_2_range, λ_int_offset, label=&quot;Offset (z_h = 0.25)&quot;, linewidth=2)
plot!(p, λ_2_range, λ_2_range, label=&quot;Arithmetic mean&quot;, linestyle=:dash, color=:gray)
plot!(p, λ_2_range, 2 .* λ_2_range ./ (1 .+ λ_2_range), label=&quot;Harmonic mean&quot;, linestyle=:dot, color=:red)
p</code></pre><img src="f8d721b1.svg" alt="Example block output"/><p>The interface conductivity always lies below the arithmetic mean, reflecting the physical principle that heat flow is limited by the less conductive layer. When the interface is closer to layer 1 (offset case), the result is weighted more heavily toward <span>$\lambda_1$</span>.</p><h3 id="Building-Temperature-(Eqs.-4.37–4.38)"><a class="docs-heading-anchor" href="#Building-Temperature-(Eqs.-4.37–4.38)">Building Temperature (Eqs. 4.37–4.38)</a><a id="Building-Temperature-(Eqs.-4.37–4.38)-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Temperature-(Eqs.-4.37–4.38)" title="Permalink"></a></h3><p>The internal building temperature is a weighted average of the inner wall and roof temperatures, with weights proportional to the surface areas exposed to the building interior. The roof contribution depends on the roof fraction <span>$W_{roof}$</span> and the canyon height-to-width ratio.</p><pre><code class="language-julia hljs">sys_bt = BuildingTemperature()
compiled_bt = mtkcompile(sys_bt)

W_roof_range = 0.1:0.02:0.9
T_iB_vals = Float64[]

for wr in W_roof_range
    p = Dict(
        compiled_bt.H_canyon =&gt; 10.0, compiled_bt.H_W =&gt; 1.0, compiled_bt.W_roof =&gt; wr,
        compiled_bt.T_inner_shdwall =&gt; 293.0, compiled_bt.T_inner_sunwall =&gt; 295.0,
        compiled_bt.T_inner_roof =&gt; 290.0,
    )
    prob = ODEProblem(compiled_bt, p, (0.0, 1.0))
    sol = solve(prob)
    push!(T_iB_vals, sol[compiled_bt.T_iB_unclamped][end])
end

p = plot(W_roof_range, T_iB_vals, linewidth=2, label=&quot;T_iB&quot;,
    xlabel=&quot;Roof Fraction W_roof&quot;, ylabel=&quot;Building Temperature (K)&quot;,
    title=&quot;Internal Building Temperature (Eqs. 4.37-4.38)&quot;, legend=:topright)
hline!(p, [293.0], label=&quot;T_shdwall&quot;, linestyle=:dash, color=:blue)
hline!(p, [295.0], label=&quot;T_sunwall&quot;, linestyle=:dash, color=:red)
hline!(p, [290.0], label=&quot;T_roof&quot;, linestyle=:dash, color=:green)
p</code></pre><img src="acb3dfc3.svg" alt="Example block output"/><p>As the roof fraction increases, the building temperature shifts from the wall-dominated average towards the roof temperature. At small roof fractions, the two wall surfaces dominate and <span>$T_{iB}$</span> lies between <span>$T_{sunwall}$</span> and <span>$T_{shdwall}$</span>.</p><h3 id="Grid-Discretization-(Eqs.-4.5–4.8)"><a class="docs-heading-anchor" href="#Grid-Discretization-(Eqs.-4.5–4.8)">Grid Discretization (Eqs. 4.5–4.8)</a><a id="Grid-Discretization-(Eqs.-4.5–4.8)-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Discretization-(Eqs.-4.5–4.8)" title="Permalink"></a></h3><p>Roofs and walls use a uniform grid (Eq. 4.5) while roads use an exponential grid (Eq. 4.8) that provides finer resolution near the surface. The exponential scaling factor <span>$f_s = 0.025$</span> m concentrates layers where the diurnal thermal wave has the largest amplitude.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqDefault

N = 10
sys_ug = UniformGrid(N=N)
compiled_ug = mtkcompile(sys_ug)
prob_ug = ODEProblem(compiled_ug, [compiled_ug.Δz_total =&gt; 0.5], (0.0, 1.0))
sol_ug = solve(prob_ug)

sys_eg = ExponentialGrid(N=N)
compiled_eg = mtkcompile(sys_eg)
prob_eg = ODEProblem(compiled_eg, [], (0.0, 1.0))
sol_eg = solve(prob_eg)

obs_ug = Dict(string(o.lhs) =&gt; o.lhs for o in observed(compiled_ug))
obs_eg = Dict(string(o.lhs) =&gt; o.lhs for o in observed(compiled_eg))

z_uniform = [sol_ug[obs_ug[&quot;z_node[$i](t)&quot;]][end] for i in 1:N]
z_exp = [sol_eg[obs_eg[&quot;z_node[$i](t)&quot;]][end] for i in 1:N]

p = plot(1:N, z_uniform, marker=:circle, label=&quot;Uniform (roof/wall)&quot;, linewidth=2,
    xlabel=&quot;Layer Index&quot;, ylabel=&quot;Node Depth (m)&quot;,
    title=&quot;Grid Node Depths (Eqs. 4.5, 4.8)&quot;, legend=:topleft)
plot!(p, 1:N, z_exp, marker=:square, label=&quot;Exponential (road)&quot;, linewidth=2)
p</code></pre><img src="932a8e4b.svg" alt="Example block output"/><p>The uniform grid spaces nodes equally, while the exponential grid clusters nodes near the surface (small indices) and spaces them progressively farther apart at depth, providing better resolution where surface forcing varies most.</p><h3 id="Freezing-Point-Depression-(Eq.-4.58)"><a class="docs-heading-anchor" href="#Freezing-Point-Depression-(Eq.-4.58)">Freezing Point Depression (Eq. 4.58)</a><a id="Freezing-Point-Depression-(Eq.-4.58)-1"></a><a class="docs-heading-anchor-permalink" href="#Freezing-Point-Depression-(Eq.-4.58)" title="Permalink"></a></h3><p>Below the freezing point, liquid water coexists with ice in soil through a freezing point depression mechanism. The maximum liquid water content decreases with temperature according to the matric potential relationship.</p><pre><code class="language-julia hljs">sys_fpd = FreezingPointDepression()
compiled_fpd = mtkcompile(sys_fpd)

T_range = 253.15:0.5:273.15
w_liq_vals = Float64[]

for T in T_range
    p = Dict(
        compiled_fpd.T_i =&gt; T,
        compiled_fpd.θ_sat =&gt; 0.4,
        compiled_fpd.Δz =&gt; 0.5,
        compiled_fpd.ψ_sat =&gt; -0.1,
        compiled_fpd.B_i =&gt; 5.0,
        compiled_fpd.ρ_liq =&gt; 1000.0,
    )
    prob = ODEProblem(compiled_fpd, p, (0.0, 1.0))
    sol = solve(prob)
    push!(w_liq_vals, sol[compiled_fpd.w_liq_max][end])
end

p = plot(T_range .- 273.15, w_liq_vals, linewidth=2, label=&quot;w_liq_max&quot;,
    xlabel=&quot;Temperature (°C)&quot;, ylabel=&quot;Max Liquid Water (kg m⁻²)&quot;,
    title=&quot;Freezing Point Depression (Eq. 4.58)&quot;, legend=:topleft)
vline!(p, [0.0], label=&quot;T_f&quot;, linestyle=:dash, color=:gray)
p</code></pre><img src="a06d4649.svg" alt="Example block output"/><p>At the freezing point (0°C), the maximum liquid water equals the fully saturated value <span>$\Delta z \cdot \theta_{sat} \cdot \rho_{liq}$</span>. As temperature decreases below freezing, the available liquid water decreases rapidly following the Clapp and Hornberger (1978) relationship.</p><h3 id="Roof/Wall-Heat-Conduction-(Eq.-4.4)"><a class="docs-heading-anchor" href="#Roof/Wall-Heat-Conduction-(Eq.-4.4)">Roof/Wall Heat Conduction (Eq. 4.4)</a><a id="Roof/Wall-Heat-Conduction-(Eq.-4.4)-1"></a><a class="docs-heading-anchor-permalink" href="#Roof/Wall-Heat-Conduction-(Eq.-4.4)" title="Permalink"></a></h3><p>The 1D heat equation for roof and wall surfaces is discretized using MethodOfLines.jl. The following example demonstrates the steady-state temperature profile with a constant surface heat flux of 50 W/m² at the top and a fixed building temperature of 290 K at the bottom.</p><p>At steady state (<span>$\partial T / \partial t = 0$</span>), the heat equation reduces to <span>$d^2T/dz^2 = 0$</span>, giving a linear temperature profile <span>$T(z) = T_{iB} + h(L-z)/\lambda$</span>.</p><pre><code class="language-julia hljs">using MethodOfLines, DomainSets

L = 0.3
λ_val = 1.5
h_val = 50.0
T_iB = 290.0

result = RoofWallHeatConduction(;
    Δz_total = L, N_layers = 30,
    λ_val = λ_val, c_val = 2.0e6,
    h_top = h_val, T_bottom = T_iB,
)

# Solve for long time to reach steady state
prob2 = remake(result.prob; tspan = (0.0, 100000.0))
sol = solve(prob2)

T_mat = sol[result.T(result.t_pde, result.z_var)]
z_disc = sol[result.z_var]
T_final = T_mat[end, :]

# Analytical solution
z_analytical = range(0, L, length=100)
T_analytical = T_iB .+ h_val .* (L .- z_analytical) ./ λ_val

p = plot(z_analytical, T_analytical, label=&quot;Analytical&quot;, linewidth=2, linestyle=:dash,
    xlabel=&quot;Depth z (m)&quot;, ylabel=&quot;Temperature (K)&quot;,
    title=&quot;Roof/Wall Steady-State Temperature Profile&quot;, legend=:topright)
scatter!(p, z_disc, T_final, label=&quot;MethodOfLines&quot;, markersize=4)
p</code></pre><img src="ce0db59a.svg" alt="Example block output"/><h3 id="Road-Heat-Conduction-with-Zero-Flux-Bottom-(Eq.-4.4)"><a class="docs-heading-anchor" href="#Road-Heat-Conduction-with-Zero-Flux-Bottom-(Eq.-4.4)">Road Heat Conduction with Zero-Flux Bottom (Eq. 4.4)</a><a id="Road-Heat-Conduction-with-Zero-Flux-Bottom-(Eq.-4.4)-1"></a><a class="docs-heading-anchor-permalink" href="#Road-Heat-Conduction-with-Zero-Flux-Bottom-(Eq.-4.4)" title="Permalink"></a></h3><p>Road surfaces use the same heat equation but with a zero heat flux (insulated) boundary condition at the bottom. With zero flux at both boundaries, the temperature remains uniform at its initial value, demonstrating energy conservation.</p><pre><code class="language-julia hljs">T_init = 288.15
result_road = RoadHeatConduction(;
    N_layers = 15,
    λ_val = 1.5, c_val = 2.0e6,
    h_top = 0.0, T_init_val = T_init,
)

sol_road = solve(result_road.prob, saveat = 0.1)
T_mat_road = sol_road[result_road.T(result_road.t_pde, result_road.z_var)]

t_disc = sol_road[result_road.t_pde]
avg_T = [mean(T_mat_road[i, :]) for i in 1:length(t_disc)]

using Statistics
p = plot(t_disc, avg_T, linewidth=2, label=&quot;Mean temperature&quot;,
    xlabel=&quot;Time (s)&quot;, ylabel=&quot;Temperature (K)&quot;,
    title=&quot;Road Energy Conservation (zero flux BCs)&quot;, legend=:topright)
hline!(p, [T_init], label=&quot;Initial T&quot;, linestyle=:dash, color=:red)
p</code></pre><img src="bcc52858.svg" alt="Example block output"/><p>With insulated (zero-flux) boundary conditions on both sides, the average temperature remains constant, confirming energy conservation in the discretized system.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../heat_momentum_fluxes/">« Heat and Momentum Fluxes</a><a class="docs-footer-nextpage" href="../hydrology/">Hydrology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 16:35">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
